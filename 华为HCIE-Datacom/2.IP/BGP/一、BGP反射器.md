```
在一个AS内，为了防止出现路由黑洞需要如何设置？  
1.建立全互联的IBGP邻居  
2.通过路由反射器  
3.建立BGP联盟
```

```
路由反射器：route-reflect  
一个路由反射器影响的范围称之为一个反射簇  
在一个簇内的设备角色：  
1.RR反射器：管理员手工指定的设备    
[AR3-bgp]peer 1.1.1.1 reflect-client   
  该命令的功能： 1.配置该命令自身成为RR     
2.指定邻居成为RR-client  
2.RR-client：客户端没有任何感知  
3.N-client：非客户端没有任何感知
```

```
邻居关系建立：  
1.客户端和RR建立IBGP邻居  
2.非客户端和RR建立IBGP邻居  
3.RR和RR建立IBGP邻居
```

```
反射器路由信息的传递：  
1.RR收到客户端的路由可以传递给非客户端  
2.RR收到客户端的路由可以传递给客户端  
3.RR收到非客户端的路由可以传递给客户端  
4.RR收到非客户端的路由不能传递给非客户端
```
 
```
***非非不传*** 
```

```
RR反射路由时，对于路由的属性如何设置？  
*RR只会反射路由，不会进行路由信息的更改  
 就算执行了下一跳更改的命令也不会更改下一跳  
       [AR3-bgp]peer 2.2.2.2 next-hop-local 
```

```
因为RR的存在打破了IBGP内水平分割的防环机制，所以可能存在环路的风险
```
 
```
RR需要存在防止环路的能力
```

```
*在一个RR反射簇内解决的环路问题￼RR路由传递防环规则场景1：  
场景1：客户端1链接两个RR设备，AR1不向AR2通告路由信息（操作1）  
RR1收到客户端1的路由，反射给RR2  
RR2收到RR1的路由，反射给客户端  
客户端1接收客户端1的路由信息导致环路
```
 
```
解决：  
通过为路由设置（Originator id）起源者ID属性来解决  
该属性通过RR设备进行设置（客户端不参与）  
RR设备会将客户端的RID作为起源者ID的属性值进行设置  
RR设备收到客户端的路由：  
  1.如果路由没有携带起源者ID属性，则为其添加  
  2.如果路由携带了起源者ID属性，则不做改变  
客户端如果接收到的路由携带了起源者ID属性：  
  会将起源者ID属性和自身的RID值进行对比  
   1.如果值不同，则接接收该路由   
   2.如果值相同，则丢弃该路由
```

![Exported image](Exported%20image%2020251206164609-0.png)

```
（操作1）如何不将AR1通告的路由信息传递给AR2：￼1.route-policy 1 deny node 20￼2.peer 10.2.2.2 route-policy 1 export  * 在建立IBGP邻居的时候不发送路由信息
```

![Exported image](Exported%20image%2020251206164610-1.png)

```
RR路由传递防环规则场景2：  
场景：  
客户端1发布的路由传递给RR1，（操作2，AR3不向AR2通告路由信息）  
RR1收到路由后，反射给RR3  
RR3收到路由后，反射给RR2  
RR2收到路由后，反射给RR3  
RR3接收反射回来的路由，则会形成路由环路
```
   

```
解决：  
通过Cluster list（簇列表）来解决环路  
簇列表中会包含簇ID值  
簇ID值 就是 反射器的RID  
反射器在反射路由后，会将自身的RID填充到簇列表中  
每经过一个RR反射器，都会从右往左依次添加RR设备的RID  
如果RR设备收到路由信息携带簇列表：  
  需要检查自身的RID和簇列表携带的簇ID是否相等  
  1.如果没有相等，则正常接收路由  
  2.如果相等，丢弃该路由
```

![Exported image](Exported%20image%2020251206164612-2.png)

```
（操作2，AR3不向AR2通告路由信息）  
1.route-policy 1 deny node 20￼2.peer 10.2.2.2 route-policy 1 export  * 在建立IBGP邻居的时候不通告路由信息
```

![Exported image](Exported%20image%2020251206164614-3.png)

```
备份路由反射器：  
RR反射器的使用场景：  
1.备份RR，为了保障RR的可靠性 通过设置备份RR来实现  
          为了解决反射簇内的多RR路由环路问题（可以通过起源者ID来实现）  
          也可通过设置簇ID值来实现[AR3-bgp]reflector cluster-id 100.3.10.3  
          两台RR设置相同的簇ID值，因为簇ID防环所有RR之间不会相互接收客户端的路由信息  
          对于RR自身产生的路由，不会携带簇ID，所以RR之间可以相互接收
```
 
```
2.分级RR，设备作为上一级设备的client，也作为下一级设备的RR
```
 
```
3.同级RR，对于大型广域网络，划分为多个RR反射簇  
          一个骨干网被分成多个集群。各集群的RR互为非客户机关系，并建立全连接
```